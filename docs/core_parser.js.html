<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"><title>core/parser.js - MathLive Docs</title><meta name="description" content="Beautifully typeset math made easy"><meta name="keywords" content="latex, tex, math, typesetting, documentation, docs">

    <meta name="viewport" content="width=device-width, initial-scale=1">


    
        <link rel="stylesheet" href="http://mathlive.io/sprint15/mathlive/mathlive.core.css" type="text/css"><link rel="stylesheet" href="http://mathlive.io/sprint15/mathlive/mathlive.css" type="text/css">
    


    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:400,400i,700,900" rel="stylesheet">
    <style>pre.prettyprint{background: #35434e;}</style>
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow-night.css">

    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>


<div class="forkme"><a href="https://github.com/arnog/mathlive"><img style="position: absolute; top: 0; right: 0; border: 0; z-index:1;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"></a></div>


<section role="navigation">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
    </label>

    <label for="nav-trigger" class="overlay"></label>

    <nav id="nav">
        <h3 class="group-title home"><a href="index.html">MathLive Docs</a></h3><input class="search" placeholder="Search" type="text"><div class="list"><h3 class="group-title">Tutorials</h3><ul><li><a href="tutorial-CONTRIBUTOR_GUIDE.html">Contributor Guide</a><ul></ul></li><li><a href="tutorial-MASTON.html">MASTON</a><ul></ul></li><li><a href="tutorial-USAGE_GUIDE.html">Usage Guide</a><ul><li><a href="tutorial-EXAMPLES.html">Examples</a></li><li><a href="tutorial-COMMANDS_REFERENCE.html">Commands Reference</a></li></ul></li></ul><h3 class="group-title">Modules</h3><ul><li class="private"><a href="module-color.html" class="className">color</a><ul class='methods private'><li data-type='method' class='private'><a href="module-color.html#.stringToColor" class="methodName">stringToColor</a></li></ul></li><li class="private"><a href="module-definitions.html" class="className">definitions</a><ul class='methods private'><li data-type='method' class='private'><a href="module-definitions.html#.defineEnvironment" class="methodName">defineEnvironment</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineFunction" class="methodName">defineFunction</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbol" class="methodName">defineSymbol</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbolRange" class="methodName">defineSymbolRange</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbols" class="methodName">defineSymbols</a></li><li data-type='method' class='private'><a href="module-definitions.html#.frequency" class="methodName">frequency</a></li><li data-type='method' class='private'><a href="module-definitions.html#.getInfo" class="methodName">getInfo</a></li><li data-type='method' class='private'><a href="module-definitions.html#.matchCodepoint" class="methodName">matchCodepoint</a></li><li data-type='method' class='private'><a href="module-definitions.html#.matchFunction" class="methodName">matchFunction</a></li><li data-type='method' class='private'><a href="module-definitions.html#.parseParamTemplateArgument" class="methodName">parseParamTemplateArgument</a></li><li data-type='method' class='private'><a href="module-definitions.html#.suggest" class="methodName">suggest</a></li><li data-type='method' class='private'><a href="module-definitions.html#~getSimpleString" class="methodName">getSimpleString</a></li><li data-type='method' class='private'><a href="module-definitions.html#~mathVariantToUnicode" class="methodName">mathVariantToUnicode</a></li></ul></li><li class="private"><a href="module-delimiters.html" class="className">delimiters</a><ul class='methods private'><li data-type='method' class='private'><a href="module-delimiters.html#.makeCustomSizedDelim" class="methodName">makeCustomSizedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeInner" class="methodName">makeInner</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeLargeDelim" class="methodName">makeLargeDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeLeftRightDelim" class="methodName">makeLeftRightDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeNullFence" class="methodName">makeNullFence</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeSizedDelim" class="methodName">makeSizedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeSmallDelim" class="methodName">makeSmallDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeStackedDelim" class="methodName">makeStackedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.traverseSequence" class="methodName">traverseSequence</a></li><li data-type='method' class='private'><a href="module-delimiters.html#~delimTypeToFont" class="methodName">delimTypeToFont</a></li></ul></li><li class="private"><a href="module-editor_editableMathlist.html" class="className">editor/editableMathlist</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~arrayCell" class="methodName">arrayCell</a></li><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~arrayCellCount" class="methodName">arrayCellCount</a></li><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~arrayColRow" class="methodName">arrayColRow</a></li><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~arrayIndex" class="methodName">arrayIndex</a></li><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~atomContains" class="methodName">atomContains</a></li><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~getString" class="methodName">getString</a></li></ul></li><li class="private"><a href="module-editor_keyboard.html" class="className">editor/keyboard</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_keyboard.html#.delegateKeyboardEvents" class="methodName">delegateKeyboardEvents</a></li><li data-type='method' class='private'><a href="module-editor_keyboard.html#.keyboardEventToString" class="methodName">keyboardEventToString</a></li></ul></li><li class="private"><a href="module-editor_mathfield.html" class="className">editor/mathfield</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_mathfield.html#nearestElementFromPoint" class="methodName">nearestElementFromPoint</a></li><li data-type='method' class='private'><a href="module-editor_mathfield.html#~_findElementWithCaret" class="methodName">_findElementWithCaret</a></li><li data-type='method' class='private'><a href="module-editor_mathfield.html#~_onAnnounce" class="methodName">_onAnnounce</a></li></ul></li><li class="private"><a href="module-editor_mathpath.html" class="className">editor/mathpath</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathCommonAncestor" class="methodName">pathCommonAncestor</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathDistance" class="methodName">pathDistance</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathFromString" class="methodName">pathFromString</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathToString" class="methodName">pathToString</a></li></ul></li><li class="private"><a href="module-editor_shortcuts.html" class="className">editor/shortcuts</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.match" class="methodName">match</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.matchKeystroke" class="methodName">matchKeystroke</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.platform" class="methodName">platform</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.stringify" class="methodName">stringify</a></li></ul></li><li class="private"><a href="module-fontMetrics.html" class="className">fontMetrics</a><ul class='methods private'><li data-type='method' class='private'><a href="module-fontMetrics.html#.getCharacterMetrics" class="methodName">getCharacterMetrics</a></li><li data-type='method' class='private'><a href="module-fontMetrics.html#~convertDimenToEm" class="methodName">convertDimenToEm</a></li></ul></li><li class="private"><a href="module-lexer.html" class="className">lexer</a><ul class='methods private'><li data-type='method' class='private'><a href="module-lexer.html#.tokenize" class="methodName">tokenize</a></li></ul></li><li class="private"><a href="module-mathAtom.html" class="className">mathAtom</a><ul class='methods private'><li data-type='method' class='private'><a href="module-mathAtom.html#.decompose" class="methodName">decompose</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.getFontName" class="methodName">getFontName</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeColGap" class="methodName">makeColGap</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeColOfRepeatingElements" class="methodName">makeColOfRepeatingElements</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeStack" class="methodName">makeStack</a></li></ul></li><li><a href="module-mathlive.html" class="className">mathlive</a><ul class='methods'><li data-type='method'><a href="module-mathlive.html#latexToAST" class="methodName">latexToAST</a></li><li data-type='method'><a href="module-mathlive.html#latexToMarkup" class="methodName">latexToMarkup</a></li><li data-type='method'><a href="module-mathlive.html#latexToMathML" class="methodName">latexToMathML</a></li><li data-type='method'><a href="module-mathlive.html#makeMathField" class="methodName">makeMathField</a></li><li data-type='method'><a href="module-mathlive.html#pauseReadAloud" class="methodName">pauseReadAloud</a></li><li data-type='method'><a href="module-mathlive.html#playReadAloud" class="methodName">playReadAloud</a></li><li data-type='method'><a href="module-mathlive.html#readAloud" class="methodName">readAloud</a></li><li data-type='method'><a href="module-mathlive.html#readAloudStatus" class="methodName">readAloudStatus</a></li><li data-type='method'><a href="module-mathlive.html#renderMathInDocument" class="methodName">renderMathInDocument</a></li><li data-type='method'><a href="module-mathlive.html#renderMathInElement" class="methodName">renderMathInElement</a></li><li data-type='method'><a href="module-mathlive.html#resumeReadAloud" class="methodName">resumeReadAloud</a></li><li data-type='method'><a href="module-mathlive.html#revertToOriginalContent" class="methodName">revertToOriginalContent</a></li><li data-type='method'><a href="module-mathlive.html#revertToOriginalContent" class="methodName">revertToOriginalContent</a></li><li data-type='method'><a href="module-mathlive.html#~highlightAtomID" class="methodName">highlightAtomID</a></li></ul></li><li class="private"><a href="module-mathstyle.html" class="className">mathstyle</a><ul class='methods private'><li data-type='method' class='private'><a href="module-mathstyle.html#.toMathstyle" class="methodName">toMathstyle</a></li></ul></li><li class="private"><a href="module-span.html" class="className">span</a><ul class='methods private'><li data-type='method' class='private'><a href="module-span.html#.coalesce" class="methodName">coalesce</a></li><li data-type='method' class='private'><a href="module-span.html#.makeFontSizer" class="methodName">makeFontSizer</a></li><li data-type='method' class='private'><a href="module-span.html#.makeHlist" class="methodName">makeHlist</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSpan" class="methodName">makeSpan</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSpanOfType" class="methodName">makeSpanOfType</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSymbol" class="methodName">makeSymbol</a></li><li data-type='method' class='private'><a href="module-span.html#.makeVlist" class="methodName">makeVlist</a></li><li data-type='method' class='private'><a href="module-span.html#.toString" class="methodName">toString</a></li><li data-type='method' class='private'><a href="module-span.html#~makeSVG" class="methodName">makeSVG</a></li></ul></li></ul><h3 class="group-title">Classes</h3><ul><li class="private"><a href="Context.html" class="className">Context</a><ul class='methods private'><li data-type='method' class='private'><a href="Context.html#clone" class="methodName">clone</a></li><li data-type='method' class='private'><a href="Context.html#cloneWith" class="methodName">cloneWith</a></li><li data-type='method' class='private'><a href="Context.html#getBackgroundColor" class="methodName">getBackgroundColor</a></li><li data-type='method' class='private'><a href="Context.html#getColor" class="methodName">getColor</a></li><li data-type='method' class='private'><a href="Context.html#setMathstyle" class="methodName">setMathstyle</a></li><li data-type='method' class='private'><a href="Context.html#withMathstyle" class="methodName">withMathstyle</a></li></ul></li><li><a href="EditableMathlist.html" class="className">EditableMathlist</a><ul class='methods'><li data-type='method'><a href="EditableMathlist.html#_addCell" class="methodName">_addCell</a></li><li data-type='method'><a href="EditableMathlist.html#_deleteAtoms" class="methodName">_deleteAtoms</a></li><li data-type='method'><a href="EditableMathlist.html#addColumnAfter_" class="methodName">addColumnAfter_</a></li><li data-type='method'><a href="EditableMathlist.html#addColumnBefore_" class="methodName">addColumnBefore_</a></li><li data-type='method'><a href="EditableMathlist.html#addRowAfter_" class="methodName">addRowAfter_</a></li><li data-type='method'><a href="EditableMathlist.html#addRowBefore_" class="methodName">addRowBefore_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#ancestor" class="methodName">ancestor</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#anchor" class="methodName">anchor</a></li><li data-type='method'><a href="EditableMathlist.html#applyStyle" class="methodName">applyStyle</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#commandOffsets" class="methodName">commandOffsets</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#commitCommandStringBeforeInsertionPoint" class="methodName">commitCommandStringBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#contains" class="methodName">contains</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#decorateCommandStringAroundInsertionPoint" class="methodName">decorateCommandStringAroundInsertionPoint</a></li><li data-type='method'><a href="EditableMathlist.html#delete" class="methodName">delete</a></li><li data-type='method'><a href="EditableMathlist.html#delete_" class="methodName">delete_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteAll_" class="methodName">deleteAll_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteNextChar_" class="methodName">deleteNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteNextWord_" class="methodName">deleteNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#deletePreviousChar_" class="methodName">deletePreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#deletePreviousWord_" class="methodName">deletePreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToGroupEnd_" class="methodName">deleteToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToGroupStart_" class="methodName">deleteToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToMathFieldEnd_" class="methodName">deleteToMathFieldEnd_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#endOffset" class="methodName">endOffset</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extend" class="methodName">extend</a></li><li data-type='method'><a href="EditableMathlist.html#extendDown_" class="methodName">extendDown_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToGroupEnd_" class="methodName">extendToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToGroupStart_" class="methodName">extendToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToMathFieldEnd_" class="methodName">extendToMathFieldEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToMathFieldStart_" class="methodName">extendToMathFieldStart_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextBoundary_" class="methodName">extendToNextBoundary_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextChar_" class="methodName">extendToNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextWord_" class="methodName">extendToNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousBoundary_" class="methodName">extendToPreviousBoundary_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousChar_" class="methodName">extendToPreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousWord_" class="methodName">extendToPreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#extendUp_" class="methodName">extendUp_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractCharactersBeforeInsertionPoint" class="methodName">extractCharactersBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractCommandStringAroundInsertionPoint" class="methodName">extractCommandStringAroundInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractContents" class="methodName">extractContents</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractContentsOrdInGroupBeforeInsertionPoint" class="methodName">extractContentsOrdInGroupBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#filter" class="methodName">filter</a></li><li data-type='method'><a href="EditableMathlist.html#insert" class="methodName">insert</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#insertFirstAtom" class="methodName">insertFirstAtom</a></li><li data-type='method'><a href="EditableMathlist.html#isCollapsed" class="methodName">isCollapsed</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#jump" class="methodName">jump</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#leap" class="methodName">leap</a></li><li data-type='method'><a href="EditableMathlist.html#moveAfterParent_" class="methodName">moveAfterParent_</a></li><li data-type='method'><a href="EditableMathlist.html#moveBeforeParent_" class="methodName">moveBeforeParent_</a></li><li data-type='method'><a href="EditableMathlist.html#moveDown_" class="methodName">moveDown_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToGroupEnd_" class="methodName">moveToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToGroupStart_" class="methodName">moveToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToMathFieldEnd_" class="methodName">moveToMathFieldEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToMathFieldStart_" class="methodName">moveToMathFieldStart_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextChar_" class="methodName">moveToNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextPlaceholder_" class="methodName">moveToNextPlaceholder_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextWord_" class="methodName">moveToNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToOpposite_" class="methodName">moveToOpposite_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousChar_" class="methodName">moveToPreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousPlaceholder_" class="methodName">moveToPreviousPlaceholder_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousWord_" class="methodName">moveToPreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToSubscript_" class="methodName">moveToSubscript_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToSuperscript_" class="methodName">moveToSuperscript_</a></li><li data-type='method'><a href="EditableMathlist.html#moveUp_" class="methodName">moveUp_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#next" class="methodName">next</a></li><li data-type='method'><a href="EditableMathlist.html#selectAll_" class="methodName">selectAll_</a></li><li data-type='method'><a href="EditableMathlist.html#selectGroup_" class="methodName">selectGroup_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setExtent" class="methodName">setExtent</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setRange" class="methodName">setRange</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setSelection" class="methodName">setSelection</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#sibling" class="methodName">sibling</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#siblings" class="methodName">siblings</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#skip" class="methodName">skip</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#startOffset" class="methodName">startOffset</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#toString" class="methodName">toString</a></li><li data-type='method'><a href="EditableMathlist.html#transpose_" class="methodName">transpose_</a></li></ul></li><li class="private"><a href="Lexer.html" class="className">Lexer</a><ul class='methods private'><li data-type='method' class='private'><a href="Lexer.html#end" class="methodName">end</a></li><li data-type='method' class='private'><a href="Lexer.html#get" class="methodName">get</a></li><li data-type='method' class='private'><a href="Lexer.html#isWhiteSpace" class="methodName">isWhiteSpace</a></li><li data-type='method' class='private'><a href="Lexer.html#makeToken" class="methodName">makeToken</a></li><li data-type='method' class='private'><a href="Lexer.html#peek" class="methodName">peek</a></li><li data-type='method' class='private'><a href="Lexer.html#scan" class="methodName">scan</a></li></ul></li><li class="private"><a href="MathAtom.html" class="className">MathAtom</a><ul class='methods private'><li data-type='method' class='private'><a href="MathAtom.html#.toSpeakableText" class="methodName">toSpeakableText</a></li><li data-type='method' class='private'><a href="MathAtom.html#bind" class="methodName">bind</a></li><li data-type='method' class='private'><a href="MathAtom.html#decompose" class="methodName">decompose</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeGenfrac" class="methodName">decomposeGenfrac</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeLeftright" class="methodName">decomposeLeftright</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeLine" class="methodName">decomposeLine</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeRule" class="methodName">decomposeRule</a></li><li data-type='method' class='private'><a href="MathAtom.html#filter" class="methodName">filter</a></li><li data-type='method' class='private'><a href="MathAtom.html#makeSpan" class="methodName">makeSpan</a></li></ul></li><li><a href="MathField.html" class="className">MathField</a><ul class='methods'><li data-type='method'><a href="MathField.html#$el" class="methodName">$el</a></li><li data-type='method'><a href="MathField.html#$insert" class="methodName">$insert</a></li><li data-type='method'><a href="MathField.html#$keystroke" class="methodName">$keystroke</a></li><li data-type='method'><a href="MathField.html#$latex" class="methodName">$latex</a></li><li data-type='method'><a href="MathField.html#$perform" class="methodName">$perform</a></li><li data-type='method'><a href="MathField.html#$revertToOriginalContent" class="methodName">$revertToOriginalContent</a></li><li data-type='method'><a href="MathField.html#$selectedText" class="methodName">$selectedText</a></li><li data-type='method'><a href="MathField.html#$selectionAtStart" class="methodName">$selectionAtStart</a></li><li data-type='method'><a href="MathField.html#$selectionDepth" class="methodName">$selectionDepth</a></li><li data-type='method'><a href="MathField.html#$selectionIsCollapsed" class="methodName">$selectionIsCollapsed</a></li><li data-type='method'><a href="MathField.html#$setConfig" class="methodName">$setConfig</a></li><li data-type='method'><a href="MathField.html#$text" class="methodName">$text</a></li><li data-type='method'><a href="MathField.html#$typedText" class="methodName">$typedText</a></li><li data-type='method' class='private'><a href="MathField.html#_getCaretPosition" class="methodName">_getCaretPosition</a></li><li data-type='method' class='private'><a href="MathField.html#_onKeystroke" class="methodName">_onKeystroke</a></li><li data-type='method' class='private'><a href="MathField.html#complete_" class="methodName">complete_</a></li><li data-type='method' class='private'><a href="MathField.html#enterCommandMode_" class="methodName">enterCommandMode_</a></li><li data-type='method' class='private'><a href="MathField.html#render" class="methodName">render</a></li><li data-type='method'><a href="MathField.html#selectionAtEnd" class="methodName">selectionAtEnd</a></li><li data-type='method'><a href="MathField.html#speakAll_" class="methodName">speakAll_</a></li><li data-type='method'><a href="MathField.html#speakAllWithSynchronizedHighlighting_" class="methodName">speakAllWithSynchronizedHighlighting_</a></li><li data-type='method'><a href="MathField.html#speakGroup_" class="methodName">speakGroup_</a></li><li data-type='method'><a href="MathField.html#speakLeftSibling_" class="methodName">speakLeftSibling_</a></li><li data-type='method'><a href="MathField.html#speakParent_" class="methodName">speakParent_</a></li><li data-type='method'><a href="MathField.html#speakRightSibling_" class="methodName">speakRightSibling_</a></li><li data-type='method'><a href="MathField.html#speakSelection_" class="methodName">speakSelection_</a></li><li data-type='method'><a href="MathField.html#speakSelectionWithSynchronizedHighlighting_" class="methodName">speakSelectionWithSynchronizedHighlighting_</a></li></ul></li><li class="private"><a href="module-mathstyle.Mathstyle.html" class="className">Mathstyle</a></li><li class="private"><a href="Parser.html" class="className">Parser</a><ul class='methods private'><li data-type='method' class='private'><a href="Parser.html#end" class="methodName">end</a></li><li data-type='method' class='private'><a href="Parser.html#hasLiteral" class="methodName">hasLiteral</a></li><li data-type='method' class='private'><a href="Parser.html#hasLiteralPattern" class="methodName">hasLiteralPattern</a></li><li data-type='method' class='private'><a href="Parser.html#hasToken" class="methodName">hasToken</a></li><li data-type='method' class='private'><a href="Parser.html#lastMathAtom" class="methodName">lastMathAtom</a></li><li data-type='method' class='private'><a href="Parser.html#parseAtom" class="methodName">parseAtom</a></li><li data-type='method' class='private'><a href="Parser.html#parseKeyword" class="methodName">parseKeyword</a></li><li data-type='method' class='private'><a href="Parser.html#parseLimits" class="methodName">parseLimits</a></li><li data-type='method' class='private'><a href="Parser.html#parseSupSub" class="methodName">parseSupSub</a></li><li data-type='method' class='private'><a href="Parser.html#parseToken" class="methodName">parseToken</a></li><li data-type='method' class='private'><a href="Parser.html#placeholder" class="methodName">placeholder</a></li><li data-type='method' class='private'><a href="Parser.html#scanArg" class="methodName">scanArg</a></li><li data-type='method' class='private'><a href="Parser.html#scanColor" class="methodName">scanColor</a></li><li data-type='method' class='private'><a href="Parser.html#scanDelim" class="methodName">scanDelim</a></li><li data-type='method' class='private'><a href="Parser.html#scanDimen" class="methodName">scanDimen</a></li><li data-type='method' class='private'><a href="Parser.html#scanEnvironment" class="methodName">scanEnvironment</a></li><li data-type='method' class='private'><a href="Parser.html#scanGroup" class="methodName">scanGroup</a></li><li data-type='method' class='private'><a href="Parser.html#scanImplicitGroup" class="methodName">scanImplicitGroup</a></li><li data-type='method' class='private'><a href="Parser.html#scanLeftRight" class="methodName">scanLeftRight</a></li><li data-type='method' class='private'><a href="Parser.html#scanMacro" class="methodName">scanMacro</a></li><li data-type='method' class='private'><a href="Parser.html#scanModeSet" class="methodName">scanModeSet</a></li><li data-type='method' class='private'><a href="Parser.html#scanModeShift" class="methodName">scanModeShift</a></li><li data-type='method' class='private'><a href="Parser.html#scanNumber" class="methodName">scanNumber</a></li><li data-type='method' class='private'><a href="Parser.html#scanString" class="methodName">scanString</a></li><li data-type='method' class='private'><a href="Parser.html#scanToken" class="methodName">scanToken</a></li></ul></li><li class="private"><a href="Span.html" class="className">Span</a></li><li class="private"><a href="Token.html" class="className">Token</a></li><li class="private"><a href="UndoManager.html" class="className">UndoManager</a><ul class='methods private'><li data-type='method' class='private'><a href="UndoManager.html#canRedo" class="methodName">canRedo</a></li><li data-type='method' class='private'><a href="UndoManager.html#canUndo" class="methodName">canUndo</a></li><li data-type='method' class='private'><a href="UndoManager.html#redo" class="methodName">redo</a></li><li data-type='method' class='private'><a href="UndoManager.html#restore" class="methodName">restore</a></li><li data-type='method' class='private'><a href="UndoManager.html#save" class="methodName">save</a></li><li data-type='method' class='private'><a href="UndoManager.html#snapshot" class="methodName">snapshot</a></li><li data-type='method' class='private'><a href="UndoManager.html#undo" class="methodName">undo</a></li></ul></li></ul><h3>Globals</h3><ul><li><a href="global.html#asLatex">asLatex</a></li><li><a href="global.html#asMachineNumber">asMachineNumber</a></li><li><a href="global.html#asSymbol">asSymbol</a></li><li><a href="global.html#escapeText">escapeText</a></li><li><a href="global.html#expandLayerMarkup">expandLayerMarkup</a></li><li><a href="global.html#formatMantissa">formatMantissa</a></li><li><a href="global.html#getCanonicalName">getCanonicalName</a></li><li><a href="global.html#getLatexForSymbol">getLatexForSymbol</a></li><li><a href="global.html#getLatexTemplateForFunction">getLatexTemplateForFunction</a></li><li><a href="global.html#getLatexTemplateForOperator">getLatexTemplateForOperator</a></li><li><a href="global.html#getPrecedence">getPrecedence</a></li><li><a href="global.html#getSymbol">getSymbol</a></li><li><a href="global.html#getType">getType</a></li><li><a href="global.html#isAtom">isAtom</a></li><li><a href="global.html#isSuperscriptAtom">isSuperscriptAtom</a></li><li><a href="global.html#latexify">latexify</a></li><li><a href="global.html#make">make</a></li><li><a href="global.html#makeKeyboardToolbar">makeKeyboardToolbar</a></li><li><a href="global.html#negate">negate</a></li><li><a href="global.html#numberAsLatex">numberAsLatex</a></li><li><a href="global.html#opPrec">opPrec</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseDelim">parseDelim</a></li><li><a href="global.html#parseDigraph">parseDigraph</a></li><li><a href="global.html#parseExpression">parseExpression</a></li><li><a href="global.html#parsePostfix">parsePostfix</a></li><li><a href="global.html#parseSupsub">parseSupsub</a></li><li><a href="global.html#parseTokens">parseTokens</a></li><li><a href="global.html#toMathML">toMathML</a></li><li><a href="global.html#validateFence">validateFence</a></li></ul><div class="checkbox"><input id="toggle-private" type="checkbox" onclick="
if (!document.getElementById('toggle-private').checked) {
document.documentElement.classList.add('no-private')
writeCookie('symbol-access', 'no-private')
} else {
document.documentElement.classList.remove('no-private')
writeCookie('symbol-access', 'private')
}
"><label for="toggle-private">Include Private Symbols</label></div></div>
        <footer role="contentInfo">
            Made with <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>. 
            
        </footer>
    </nav>
</section>

<main id="main">
    
        <h1 class="page-title">core/parser.js</h1>
    

    



    
    <section class="source">
        <article>
            <pre class="prettyprint source linenums">
            
            <code>
/**
 * @private
 */

import Definitions from './definitions.js';
import Color from './color.js';
import FontMetrics from './fontMetrics.js';
import Lexer from './lexer.js';
import MathAtomModule from './mathAtom.js';

const MathAtom = MathAtomModule.MathAtom;

/**
 * A parser transforms a list of tokens into a list of MathAtom.
 *
 * @param {InputToken[]} tokens - An array of tokens generated by the lexer.
 * @param {Object} [args] - An optional list of arguments. `#n` tokens will be
 * substituted with the corresponding element in the args array. This is used
 * when parsing macros.
 * @property {Object} [macros] - Optional macro definitions.
 * @class Parser
 * @global
 * @property {InputToken[]} tokens - An array of tokens generated by the lexer.
 * @property {Object} args - Optional arguments to substitute the `#` token.
 * @property {Object} macros - A dictionary of objects, index by the name of
 * the macro, with the following keys:
 *    * args: an integer, the number of arguments, default 0. They can be referenced as #0,
 *       #1, #2... inside the definition of the macro
 *    * def: a string, the definition of the macro, which can reference other macros
 * @property {number} index - The current token to be parsed: index in `this.tokens`
 * @property {MathAtom[]} mathList - Accumulated result of the parsing by
 * `parseAtom()`
 * @property {string} parseMode - The parse mode indicates the syntax rules to
 * use to parse the upcoming tokens.
 *  Valid values include:
 *  - `'math'`: spaces are ignored, math functions are allowed
 *  - `'text'`: spaces are accounted for, math functions are ignored
 *  - `'string'`
 *  - `'color'`: color name, hex value: `'#fff'`, `'#a0a0a0'`
 *  - `'number'`: `+/-12.56`
 *  - `'dimen'`: `'25mu'`, `'2pt'`
 *  - `'skip'`: `'25mu plus 2em minus fiLll'`, `'2pt'`
 *  - `'colspec'`: formating of a column in tabular environment, e.g. `'r@{.}l'`
 * @property {boolean} tabularMode - When in tabular mode, `'&amp;'` is interpreted as
 *  a column separator and `'\'` as a row separator. Used for matrixes, etc...
 * @property {number} endCount - Counter to prevent deadlock. If `end()` is
 * called too many times (1,000) in a row for the same token, bail.
 * @private
 */
function Parser(tokens, args, macros) {
    this.tokens = tokens;
    this.index = 0;
    this.args = args;
    this.macros = macros;
    this.mathList = [];
    this.parseMode = 'math';
    this.tabularMode = false;
    this.endCount = 0;
}

Parser.prototype.swapMathList = function(newMathList) {
    const result = this.mathList;
    this.mathList = newMathList || [];
    return result;
}

Parser.prototype.swapParseMode = function(mode) {
    const result = this.parseMode;
    this.parseMode = mode;
    return result;
}

/**
 * True if we've reached the end of the token stream.
 * @method Parser#end
 * @private
 */
Parser.prototype.end = function() {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
}

Parser.prototype.get = function() {
    this.endCount = 0;
    return this.index &lt; this.tokens.length ? this.tokens[this.index++] : null;
}

Parser.prototype.peek = function(offset) {
    const index = this.index + (offset ? offset : 0);
    return index &lt; this.tokens.length ? this.tokens[index] : null;
}

/**
 * Return the last atom of the math list.
 * If force is true (or undefined) and the list is empty, a new empty
 * atom is created and returned as the result.
 * @method Parser#lastMathAtom
 */
Parser.prototype.lastMathAtom = function() {
    if (this.mathList.length === 0 ||
        this.mathList[this.mathList.length - 1].type !== 'mop') {
        // ZERO WIDTH SPACE
        const lastAtom = new MathAtom(this.parseMode, 'msubsup', '\u200b', 'main');
        lastAtom.attributes = {
            "aria-hidden": true
        };
        this.mathList.push(lastAtom);
    }
    return this.mathList[this.mathList.length - 1];
}

/**
 * @param {string} type
 * @return {boolean} True if the next token is of the specified type
 * @method Parser#hasToken
 */
Parser.prototype.hasToken = function(type) {
    const index = this.index;
    return index &lt; this.tokens.length ?
        this.tokens[index].type === type : false;
}

/**
 * @param {string} [value]
 * @return {boolean} True if the next token is of type `'literal` and has the
 * specified value. If `value` is empty, return true if the token is of type
 * `'literal'`
 * @method Parser#hasLiteral
 */
Parser.prototype.hasLiteral = function(value) {
    const index = this.index;
    return index &lt; this.tokens.length ?
        this.tokens[index].type === 'literal' &amp;&amp;
        (!value || this.tokens[index].value === value) : false;
}

/**
 * @param {RegEx} pattern
 * @return {boolean} True if the next token is of type `'literal` and matches
 * the specified regular expression pattern.
 * @method Parser#hasLiteralPattern
 */
Parser.prototype.hasLiteralPattern = function(pattern) {
    return this.hasToken('literal') &amp;&amp;
        pattern.test(this.tokens[this.index].value);
}

Parser.prototype.hasCommand = function(command) {
    console.assert(command === '\\' || command.charAt(0) !== '\\',
        'hasCommand() does not require a \\');

    const index = this.index;
    return index &lt; this.tokens.length ?
        this.tokens[index].type === 'command' &amp;&amp;
        this.tokens[index].value === command : false;
}

Parser.prototype.hasInfixCommand = function() {
    const index = this.index;
    if (index &lt; this.tokens.length &amp;&amp;
        this.tokens[index].type === 'command') {
        const info = Definitions.getInfo('\\' + this.tokens[index].value,
            this.parseMode, this.macros);
        return info &amp;&amp; info.infix;
    }
    return false;
}




Parser.prototype.hasColumnSeparator = function() {
    const index = this.index;
    return this.tabularMode &amp;&amp; index &lt; this.tokens.length ?
        this.tokens[index].type === 'literal' &amp;&amp;
        this.tokens[index].value === '&amp;' : false;
}

Parser.prototype.hasRowSeparator = function() {
    const index = this.index;
    return this.tabularMode &amp;&amp; index &lt; this.tokens.length ?
        this.tokens[index].type === 'command' &amp;&amp;
        (this.tokens[index].value === '\\' ||
        this.tokens[index].value === 'cr') : false;
}

Parser.prototype.parseColumnSeparator = function() {
    if (this.hasColumnSeparator()) {
        this.index++;
        return true;
    }
    return false;
}


/**
 * Return the appropriate value for a placeholder, either a default
 * one, or if a value was provided for #? via args, that value.
 */
Parser.prototype.placeholder = function() {
    if (this.args &amp;&amp; typeof this.args['?'] === 'string') {
        // If there is a specific value defined for the placeholder,
        // use it.
        return parseTokens(Lexer.tokenize(this.args['?']), this.parseMode, null, this.macros);
    }
    // U+2753 = BLACK QUESTION MARK ORNAMENT
    return [new MathAtom(this.parseMode, 'placeholder', '?')];
}


const SIZING_COMMANDS = [
    'tiny', 'scriptsize', 'footnotesize', 'small',
    'normalsize',
    'large', 'Large', 'LARGE', 'huge', 'Huge',
];

const MATHSTYLE_COMMANDS = [
    'displaystyle', 'textstyle', 'scriptstyle', 'scriptscriptstyle',
]

Parser.prototype.hasImplicitCommand = function(commands) {
    if (this.index &lt; this.tokens.length) {
        const token = this.tokens[this.index]
        if (token.type === 'command') {
            return commands.includes(token.value);
        }
    }
    return false;
}



Parser.prototype.parseRowSeparator = function() {
    if (this.hasRowSeparator()) {
        this.index++;
        return true;
    }
    return false;
}


/**
 * @param {string} type
 * @method Parser#parseToken
 */
Parser.prototype.parseToken = function(type) {
    if (this.hasToken(type)) {
        this.index++;
        return true;
    }
    return false;
}

Parser.prototype.skipUntilToken = function(type) {
    while (!this.end() &amp;&amp; !this.parseToken(type)) {
        this.get();
    }
}


Parser.prototype.parseCommand = function(command) {
    if (this.hasCommand(command)) {
        this.index++;
        return true;
    }
    return false;
}

Parser.prototype.parseLiteral = function(literal) {
    if (this.hasLiteral(literal)) {
        this.index++;
        return true;
    }
    return false;
}

Parser.prototype.parseFiller = function() {
    let skipped = false;
    let done = false;
    do {
        const skippedSpace = this.parseToken('space');
        const skippedRelax = this.parseCommand('relax');
        skipped = skipped || skippedSpace || skippedRelax;
        done = !skippedSpace &amp;&amp; !skippedRelax;
    } while (!done);

    return skipped;
}

/**
 * Keywords are used to specify dimentions, and for various other
 * syntactic constructs. Unlike commands, they are not case sensitive.
 * There are 25 keywords:
 * at by bp cc cm dd depth em ex fil fill filll height in minus
 * mm mu pc plus pt sp spread to true width
 *
 * TeX: 8212
 * @return {boolean} true if the expected keyword is present
 * @method Parser#parseKeyword
 * @private
 */
Parser.prototype.parseKeyword = function(keyword) {
    const savedIndex = this.index;

    let done = this.end();
    let value = '';
    while(!done) {
        const token = this.get();
        if (token.type === 'literal') {
            value += token.value;
        }
        done = this.end() || token.type !== 'literal' ||
            value.length >= keyword.length;
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();

    if (!hasKeyword) this.index = savedIndex;

    return hasKeyword;
}

/**
 * Return a sequence of characters as a string.
 * i.e. 'abcd' returns 'abcd'.
 * Terminates on the first non-character encountered
 * e.g. '{', '}' etc...
 * Will also terminate on ']'
 * @return {string}
 * @method Parser#scanString
 * @private
 */
Parser.prototype.scanString = function() {
    let result = '';
    let done = this.end();
    while(!done) {
        if (this.hasLiteral(']')) {
            done = true;
        } else if (this.hasToken('literal')) {
            result += this.get().value;
            done = this.end();

        } else if (this.parseToken('space')) {
            result += ' ';
            done = this.end();

        } else if (this.hasToken('command')) {
            // TeX will give a 'Missing \endcsname inserted' error
            // if it encounters any command when expecting a string.
            // We're a bit more lax.
            const token = this.get();
            const info = Definitions.getInfo('\\' + token.value,
                this.parseMode, this.macros);
            // If parseMode is 'math', info.type will never be 'textord'
            // Otherwise, info.type will never be 'mord'
            if (info &amp;&amp; (info.type === 'mord' || info.type === 'textord') &amp;&amp; info.value) {
                result += info.value;
            }
            done = this.end();

        } else {
            done = true;
        }
    }

    return result;
}


/**
 * Return a CSS color (#rrggbb)
 * @method Parser#scanColor
 * @private
 */
Parser.prototype.scanColor = function() {
    return Color.stringToColor(this.scanString());
}

/**
 * Return as a number a group of characters representing a
 * numerical quantity.
 *
 * From TeX:8695 (scan_int):
 * An integer number can be preceded by any number of spaces and `\.+' or
 * `\.-' signs. Then comes either a decimal constant (i.e., radix 10), an
 * octal constant (i.e., radix 8, preceded by~\.\'), a hexadecimal constant
 * (radix 16, preceded by~\."), an alphabetic constant (preceded by~\.\`), or
 * an internal variable.
 * @return {number}
 * @method Parser#scanNumber
 * @private
 */
Parser.prototype.scanNumber = function(isInteger) {
    const negative = this.parseLiteral('-');

    // Optional (ignorable) '+' sign
    if (!negative) this.parseLiteral('+');
    this.parseToken('space');

    isInteger = !!isInteger;

    let radix = 10;
    let digits = /[0-9]/;
    if (this.parseLiteral("'")) {
        // Apostrophe indicates an octal value
        radix = 8;
        digits = /[0-7]/;
        isInteger = true;
    } else if (this.parseLiteral('"') || this.parseLiteral('x')) {
        // Double-quote indicates a hex value
        // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
        // For example: 'x3a'
        radix = 16;
        // Hex digits have to be upper-case
        digits = /[0-9A-F]/;
        isInteger = true;
    }

    let value = '';
    while (this.hasLiteralPattern(digits)) {
        value += this.get().value;
    }

    // Parse the fractional part, if applicable
    if (!isInteger &amp;&amp;  (this.parseLiteral('.') || this.parseLiteral(','))) {
        value += '.';
        while (this.hasLiteralPattern(digits)) {
            value += this.get().value;
        }
    }

    const result = isInteger ? parseInt(value, radix) : parseFloat(value);
    return negative ? -result : result;
}


/**
 * Return as a floating point number a dimension in pt (1 em = 10 pt)
 *
 * See TeX:8831
 * @todo: note that some units depend on the font (em, ex). So it might be
 * better to return a dimen struct with the value + unit and resolve
 * later when we have a font context....
 * @return {number}
 * @method Parser#scanDimen
 * @private
 */
Parser.prototype.scanDimen = function() {
    const value = this.scanNumber(false);

    this.parseToken('space');

    let result;

    if (this.parseKeyword('pt')) {
        result = FontMetrics.toEm(value, 'pt');
    } else if (this.parseKeyword('mm')) {
        result = FontMetrics.toEm(value, 'mm');
    } else if (this.parseKeyword('cm')) {
        result = FontMetrics.toEm(value, 'cm');
    } else if (this.parseKeyword('ex')) {
        result = FontMetrics.toEm(value, 'ex');
    } else if (this.parseKeyword('px')) {
        result = FontMetrics.toEm(value, 'px');
    } else if (this.parseKeyword('em')) {
        result = FontMetrics.toEm(value, 'em');
    } else if (this.parseKeyword('bp')) {
        result = FontMetrics.toEm(value, 'bp');
    } else if (this.parseKeyword('dd')) {
        result = FontMetrics.toEm(value, 'dd');
    } else if (this.parseKeyword('pc')) {
        result = FontMetrics.toEm(value, 'pc');
    } else if (this.parseKeyword('in')) {
        result = FontMetrics.toEm(value, 'in');
    } else if (this.parseKeyword('mu')) {
        result = FontMetrics.toEm(value, 'mu');
    } else {
        // If the units are missing, TeX assumes 'pt'
        result = FontMetrics.toEm(value, 'pt');
    }

    return result;
}

Parser.prototype.scanSkip = function() {
    const result = this.scanDimen();

    // We parse, but ignore the optional 'plus' and 'minus'
    // arguments.

    this.parseToken('space');

    // 'plus', optionally followed by 'minus'
    // ('minus' cannot come before 'plus')
    // dimen or 'hfill'

    if (this.parseKeyword('plus')) {
        // @todo there could also be a \hFilLlL command here
        this.scanDimen();
    }

    this.parseToken('space');

    if (this.parseKeyword('minus')) {
        // @todo there could also be a \hFilLlL command here
        this.scanDimen();
    }

    return result;
}


Parser.prototype.scanColspec = function() {
    this.parseToken('space');
    const result = [];
    while (!this.end() &amp;&amp; !(this.hasToken('}') || this.hasLiteral(']'))) {
        if (this.hasLiteral()) {
            const literal = this.get().value;
            if ('lcr'.includes(literal)) {
                result.push({align: literal});
            } else if (literal === '|') {
                result.push({rule: true});
            } else if (literal === '@') {
                if (this.parseToken('{')) {
                    const savedParsemode = this.swapParseMode('math');
                    result.push({gap: this.scanImplicitGroup(
                        token => token.type === '}')});
                    this.swapParseMode(savedParsemode);
                }
                this.parseToken('}');
            }
        }
    }
    return result;
}

/**
 * Parse a `\(...\)` or `\[...\]` sequence
 * @return {MathAtom} group for the sequence or null
 * @method Parser#scanModeSet
 * @private
 */
Parser.prototype.scanModeSet = function() {
    let final;
    if (this.parseCommand('(')) final = ')';
    if (!final &amp;&amp; this.parseCommand('[')) final = ']';
    if (!final) return null;

    const savedParsemode = this.swapParseMode('math');

    const result = new MathAtom('math', 'group');
    result.mathstyle = final === ')' ? 'textstyle' : 'displaystyle';
    result.body = this.scanImplicitGroup(
        token => token.type === 'command' &amp;&amp; token.value === final);
    this.parseCommand(final);

    this.swapParseMode(savedParsemode);

    if (!result.body || result.body.length === 0) return null;
    return result;
}

/**
 * Parse a `$...$` or `$$...$$` sequence
 * @method Parser#scanModeShift
 * @private
 */
Parser.prototype.scanModeShift = function() {
    if (!this.hasToken('$') &amp;&amp; !this.hasToken('$$')) return null;

    const final = this.get().type;

    const result = new MathAtom('math', 'group');
    result.mathstyle = final === '$' ? 'textstyle' : 'displaystyle';
    result.latexOpen = result.mathstyle === 'textstyle' ? '$' : '$$';
    result.latexClose = result.latexOpen;
    const savedParsemode = this.swapParseMode('math');

    result.body = this.scanImplicitGroup(token => token.type === final);

    this.parseToken(final);

    this.swapParseMode(savedParsemode);

    if (!result.body || result.body.length === 0) return null;
    return result;
}




/**
 * Parse a \begin{env}...\end{end} sequence
 * @method Parser#scanEnvironment
 * @private
 */
Parser.prototype.scanEnvironment = function() {
    // An environment starts with a \begin command
    if (!this.parseCommand('begin')) return null;

    // The \begin command is immediately followed by the environment
    // name, as a string argument
    const envName = this.scanArg('string');

    const env = Definitions.getEnvironmentInfo(envName);

    // If the environment has some arguments, parse them
    const args = [];
    if (env &amp;&amp; env.params) {
        for (const param of env.params) {
            // Parse an argument
            if (param.optional) {
                // If it's not present, return the default argument value
                const arg = this.scanOptionalArg(param.type);
                // args.push(arg ? arg : param.defaultValue); @todo defaultvalue
                args.push(arg);

            } else {
                // If it's not present, scanArg returns null,
                // but push it on the list of arguments anyway.
                // The null value will be interpreted as unspecified
                // optional value by the command handler.
                args.push(this.scanArg(param.type));
            }
        }
    }

    // Some environments change the mode
    const savedMode = this.parseMode;
    const savedTabularMode = this.tabularMode;
    const savedMathList = this.swapMathList([]);
    // @todo: since calling scanImplicitGroup(), may not need to save/restore the mathlist

    this.tabularMode = env.tabular;

    const array = [];
    const rowGaps = [];
    let row = [];

    let done = false;
    do {
        done = this.end();
        if (!done &amp;&amp; this.parseCommand('end')) {
            done = this.scanArg('string') === envName;
        }
        if (!done) {
            if (this.parseColumnSeparator()) {
                row.push(this.swapMathList([]));

            } else if (this.parseRowSeparator()) {
                row.push(this.swapMathList([]));
                let gap = 0;
                this.parseToken('space');
                if (this.parseLiteral('[')) {
                    gap = this.scanDimen();
                    this.parseToken('space');
                    this.parseLiteral(']');
                }
                rowGaps.push(gap || 0);
                array.push(row);
                row = [];
            } else {
                this.mathList = this.mathList.concat(this.scanImplicitGroup());
            }
        }
    } while (!done);

    row.push(this.swapMathList([]));
    if (row.length > 0) array.push(row);

    const newMathList = this.swapMathList(savedMathList);

    // If we're in tabular mode, we should end up with an empty mathlist
    console.assert(!this.tabularMode || newMathList.length === 0,
        'Leftover atoms in tabular mode');

    this.parseMode = savedMode;
    this.tabularMode = savedTabularMode;

    if (!env.tabular &amp;&amp; newMathList.length === 0) return null;
    if (env.tabular &amp;&amp; array.length === 0) return null;

    const result = new MathAtom(this.parseMode, 'array', null, null,
        env.parser ? env.parser(envName, args, array) : {});
    result.array = array;
    result.body = newMathList;
    result.rowGaps = rowGaps;
    result.env = env;
    result.env.name = envName;

    return result;
}

/**
 * Parse a sequence terminated with a group end marker, such as
 * `}`, `\end`, `&amp;`, etc...
 * Returns an array of atoms or an empty array if the sequence
 * terminates right away.
 * @param {function(Token):boolean} [done] A predicate indicating if a token signals the
 * end of an implicit group
 * @return {MathAtom[]}
 * @method Parser#scanImplicitGroup
 * @private
 */
Parser.prototype.scanImplicitGroup = function(done) {
    // {black\color{red}red\color{green}green}black
    // An implicit group is a sequence of atoms that terminates with
    // a `'}'`, `'&amp;'`, `'\'`, `'\cr'` or `'\end'` or the end of the stream
    if (!done) {
        done =  token =>
         token.type === '}' ||
        (token.type === 'literal' &amp;&amp; token.value === '&amp;') ||
        (token.type === 'command' &amp;&amp; (
            token.value === 'end' ||
            token.value === 'cr' ||
            token.value === '\\'
        ));
    }
    // To handle infix operators, we'll keep track of their prefix
    // (tokens coming before them)
    let infix = null;     // A token
    let prefix = null;    // A mathlist

    const savedMathlist = this.swapMathList([]);
    // if (this.index >= this.tokens.length) return true;
    // const token = this.tokens[this.index];
    while(!this.end() &amp;&amp; !done(this.peek())) {
        if (this.hasImplicitCommand(SIZING_COMMANDS)) {
            // Implicit sizing command such as \Large, \small
            // affect the tokens following them
            // Note these commands are only appropriate in 'text' mode.
            const atom = new MathAtom(this.parseMode, 'sizing');
            atom.size = {
                'tiny' : 'size1',
                'scriptsize': 'size2',
                'footnotesize': 'size3',
                'small' : 'size4',
                'normalsize': 'size5',
                'large': 'size6',
                'Large': 'size7',
                'LARGE': 'size8',
                'huge': 'size9',
                'Huge': 'size10'
            }[this.get().value];
            this.mathList.push(atom);

        } else if (this.hasImplicitCommand(MATHSTYLE_COMMANDS)) {
            // Implicit math style commands such as \displaystyle, \textstyle...
            // Note these commands switch to math mode and a specific size
            // \textsize is the mathstyle used for inlinemath, not for text
            this.parseMode = 'math';
            const atom = new MathAtom('math', 'mathstyle');
            atom.mathstyle = this.get().value;
            this.mathList.push(atom);

        } else if (this.hasInfixCommand() &amp;&amp; !infix) {
            // The next token is an infix and we have not seen one yet
            // (there can be only one infix command per implicit group).
            infix = this.get();
            // Save the math list so far and start a new one
            prefix = this.swapMathList([]);

        } else {
            this.parseAtom();
        }
    }


    let result;

    if (infix) {
        const suffix = this.swapMathList(savedMathlist);
        // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode
        const info = Definitions.getInfo('\\' + infix.value,
            'math', this.macros);
        if (info) {
            result =  [new MathAtom(
                this.parseMode, info.type || 'mop',
                info.value || infix.value,
                info.fontFamily,
                info.handler ?
                    info.handler('\\' + infix.value, [prefix, suffix]) :
                    null)];
        } else {
            result =  [new MathAtom(
                this.parseMode, 'mop', infix.value, '', null)];
        }
    } else {
        result = this.swapMathList(savedMathlist);
    }
    return result;
}

/**
 * Parse a group enclosed in a pair of braces: `{...}`.
 *
 * Return either a group MathAtom or null if not a group.
 *
 * Return a group MathAtom with an empty body if an empty
 * group (i.e. `{}`).
 * @return {MathAtom}
 * @method Parser#scanGroup
 * @private
 */
Parser.prototype.scanGroup = function() {
    if (!this.parseToken('{')) return null;

    const result = new MathAtom(this.parseMode, 'group');
    result.body = this.scanImplicitGroup(token => token.type === '}');
    this.parseToken('}');

    return result;
}


Parser.prototype.scanSmartFence = function() {
    this.parseToken('space');
    if (!this.parseLiteral('(')) return null;

    // We've found an open paren... Convert to a `\mleft...\mright`
    const result = new MathAtom(this.parseMode, 'leftright');
    result.leftDelim = '(';
    result.inner = false;   // It's a `\mleft`, not a `\left`

    const savedMathList = this.swapMathList([]);
    let nestLevel = 1;
    while(!this.end() &amp;&amp; nestLevel !== 0) {
        if (this.hasLiteral('(')) nestLevel += 1;
        if (this.hasLiteral(')')) nestLevel -= 1;
        if (nestLevel !== 0) this.parseAtom();
    }
    if (nestLevel === 0) this.parseLiteral(')');

    result.rightDelim = nestLevel === 0 ? ')' : '?';
    result.body = this.swapMathList(savedMathList);

    return result;
}


/**
 * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
 *
 * @return {string} The delimiter (as a character or command) or null
 * @memberof Parser
 * @method Parser#scanDelim
 * @private
 */
Parser.prototype.scanDelim = function() {
    this.parseToken('space');

    const token = this.get();
    if (!token) return null;

    let delim = '.';
    if (token.type === 'command') {
        delim = '\\' + token.value;
    } else if (token.type === 'literal') {
        delim = token.value;
    }
    const info = Definitions.getInfo(delim, 'math', this.macros);
    if (!info) return null;

    if (info.type === 'mopen' || info.type === 'mclose') {
        return delim;
    }

    // Some symbols are not of type mopen/mclose, but are still
    // valid delimiters...
    // '?' is a special delimiter used as a 'placeholder'
    // (when the closing delimiter is displayed greyed out)
    if (['?', '|', '&lt;', '>', '\\vert', '\\Vert', '\\|', '\\surd',
        '\\uparrow', '\\downarrow', '\\Uparrow', '\\Downarrow',
        '\\updownarrow', '\\Updownarrow',
        '\\mid', '\\mvert', '\\mVert'].includes(delim)) {
        return delim;
    }

    return null;
}

/**
 * Parse a `/left.../right` sequence.
 *
 * Note: the `/middle` command can occur multiple times inside a
 * `/left.../right` sequence, and is handled separately.
 *
 * Return either an atom of type `'leftright'` or null
 * @return {MathAtom}
 * @method Parser#scanLeftRight
 * @private
 */
Parser.prototype.scanLeftRight = function() {
    if (this.parseCommand('right') || this.parseCommand('mright')) {
        // We have an unbalanced left/right (there's a \right, but no \left)
        const result = new MathAtom(this.parseMode, 'leftright');
        result.rightDelim = this.scanDelim() || '.';
        return result;
    }

    let close = 'right';
    if (!this.parseCommand('left')) {
        if (!this.parseCommand('mleft')) return null;
        close = 'mright';
    }

    const leftDelim = this.scanDelim() || '.';

    const savedMathList = this.swapMathList([]);
    while(!this.end() &amp;&amp; !this.parseCommand(close)) {
        this.parseAtom();
    }

    // If we've reached the end and there was no `\right` or
    // there isn't a valid delimiter after `\right`, we'll
    // consider the `\right` missing and set the `rightDelim` to undefined
    const rightDelim = this.scanDelim();

    const result = new MathAtom(this.parseMode, 'leftright');
    result.leftDelim = leftDelim;
    result.rightDelim = rightDelim;
    result.inner = close === 'right';
    result.body = this.swapMathList(savedMathList);

    return result;
}

/**
 * Parse a subscript/superscript: `^` and `_`.
 *
 * Modify the last atom accordingly.
 *
 * @return {MathAtom}
 * @method Parser#parseSupSub
 * @private
 */
Parser.prototype.parseSupSub = function() {
    // No sup/sub in text or command mode.
    if (this.parseMode !== 'math') return false;

    // Apply the subscript/superscript to the last render atom.
    // If none is present (beginning of the mathlist, i.e. `{^2}`,
    // an empty atom will be created, equivalent to `{{}^2}`
    let result = false;

    while (this.hasToken('^') || this.hasToken('_') || this.hasLiteral("'")) {
        let supsub;
        if (this.hasToken('^')) {
            supsub = 'superscript';
        } else if (this.hasToken('_')) {
            supsub = 'subscript';
        }
        if (this.parseToken('^') || this.parseToken('_')) {
            const arg = this.scanArg();
            if (arg) {
                const atom = this.lastMathAtom();
                atom[supsub] = atom[supsub] || [];
                atom[supsub] = atom[supsub].concat(arg);
                result = true;
            }

        } else if (this.parseLiteral("'")) {
            // A single quote (prime) is actually equivalent to a
            // '^{\prime}'
            const atom = this.lastMathAtom();
            atom.superscript = atom.superscript || [];
            atom.superscript.push(
                new MathAtom(atom.parseMode, 'mord', '\u2032', 'main')
            );
            result = true;
        }
    }

    return result;
}

/**
 * Parse a `\limits` or `\nolimits` command.
 *
 * This will change the placement of limits to be either above or below
 * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
 *
 * This overrides the calculation made for the placement, which is usually
 * dependent on the displaystyle (`inlinemath` prefers `\nolimits`, while
 * `displaymath` prefers `\limits`).
 * @method Parser#parseLimits
 * @private
 */
Parser.prototype.parseLimits = function() {
    // Note: technically, \limits and \nolimits are only applicable
    // after an operator. However, we apply them in all cases. They
    // will simply be ignored when not applicable (i.e. on a literal)
    // which is actually consistent with TeX.
    if (this.parseCommand('limits')) {
        const lastAtom = this.lastMathAtom()
        lastAtom.limits = 'limits';
        // Record that the limits was set through an explicit command
        // so we can generate the appropriate LaTeX later
        lastAtom.explicitLimits = true;
        return true;
    }
    if (this.parseCommand('nolimits')) {
        const lastAtom = this.lastMathAtom()
        lastAtom.limits = 'nolimits';
        // Record that the limits was set through an explicit command
        // so we can generate the appropriate LaTeX later
        lastAtom.explicitLimits = true;
        return true;
    }

    return false;
}

Parser.prototype.scanOptionalArg = function(parseMode) {
    parseMode = (!parseMode || parseMode === 'auto') ? this.parseMode : parseMode;
    this.parseToken('space');

    if (!this.parseLiteral('[')) return null;

    const savedParseMode = this.parseMode;
    this.parseMode = parseMode;
    const savedMathlist = this.swapMathList();
    let result;
    while (!this.end() &amp;&amp; !this.parseLiteral(']')) {
        if (parseMode === 'string') {
            result = this.scanString();
        } else if (parseMode === 'number') {
            result = this.scanNumber();
        } else if (parseMode === 'dimen') {
            result = this.scanDimen();
        } else if (parseMode === 'skip') {
            result = this.scanSkip();
        } else if (parseMode === 'colspec') {
            result = this.scanColspec();
        } else if (parseMode === 'color') {
            result = this.scanColor() || '#ffffff';
        } else if (parseMode === 'bbox') {
            // The \bbox command takes a very particular argument:
            // a comma delimited list of up to three arguments:
            // a color, a dimension and a string.
            // Split the string by comma delimited sub-strings, ignoring commas
            // that may be inside (). For example"x, rgb(a, b, c)" would return
            // ['x', 'rgb(a, b, c)']
            const list = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
            for (const elem of list) {
                const color = Color.stringToColor(elem);
                if (color) {
                    result = result || {};
                    result.backgroundcolor = color;
                } else {
                    const m = elem.match(/^\s*([0-9.]+)\s*([a-z][a-z])/);
                    if (m) {
                        result = result || {};
                        result.padding = FontMetrics.toEm(m[1], m[2]);
                    } else {
                        const m = elem.match(/^\s*border\s*:\s*(.*)/);
                        if (m) {
                            result = result || {};
                            result.border = m[1];
                        }
                    }
                }
            }
        } else {
            console.assert(parseMode === 'math',
                'Unexpected parse mode: "' + parseMode + '"');
            this.mathList = this.mathList.concat(
                this.scanImplicitGroup(token =>
                    token.type === 'literal' &amp;&amp; token.value === ']'));
        }
    }
    this.parseMode = savedParseMode;
    const mathList = this.swapMathList(savedMathlist);
    return result ? result : mathList;
}


/**
 * Parse a math field, an argument to a function.
 *
 * An argument can either be a single atom or
 * a sequence of atoms enclosed in braces.
 *
 * @param {string} [parseMode] Temporarily overrides the parser parsemode. For
 * example: `'dimension'`, `'color'`, `'text'`, etc...
 * @method Parser#scanArg
 * @private
 */
Parser.prototype.scanArg = function(parseMode) {
    parseMode = (!parseMode || parseMode === 'auto') ? this.parseMode : parseMode;
    this.parseFiller();

    let result;

    // An argument (which is called a 'math field' in TeX)
    // could be a single character or symbol, as in `\frac12`
    // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
    // ``\frac{\sqrt}{-1}{\beta}``
    if (!this.parseToken('{')) {
        if (parseMode === 'delim') {
            return this.scanDelim() || '.';
        } else if (parseMode === 'math') {
            // Parse a single atom.
            const savedParseMode = this.parseMode;
            this.parseMode = 'math';

            const atom = this.scanToken();

            this.parseMode = savedParseMode;

            if (Array.isArray(atom)) return atom;
            return atom ? [atom] : null;
        }
    }

    // If this is a param token, substitute it with the
    // (optional) argument passed to the parser
    if (this.hasToken('#')) {
        const paramToken = this.get();
        this.skipUntilToken('}');
        if (paramToken.value === '?') {
            return this.placeholder();
        }
        if (this.args) {
            if (this.args[paramToken.value] === undefined &amp;&amp;
                this.args['?'] !== undefined) {
                return this.placeholder();
            }
            return this.args[paramToken.value] || null;
        }
        return null;
    }

    const savedParseMode = this.parseMode;
    this.parseMode = parseMode;
    const savedMathList = this.swapMathList([]);


    if (parseMode === 'string') {
        result = this.scanString();
        this.skipUntilToken('}');

    } else if (parseMode === 'number') {
        result = this.scanNumber();
        this.skipUntilToken('}');

    } else if (parseMode === 'dimen') {
        result = this.scanDimen();
        this.skipUntilToken('}');

    } else if (parseMode === 'skip') {
        result = this.scanSkip();
        this.skipUntilToken('}');

    } else if (parseMode === 'colspec') {
        result = this.scanColspec();
        this.skipUntilToken('}');

    } else if (parseMode === 'color') {
        result = this.scanColor() || '#ffffff';
        this.skipUntilToken('}');

    } else if (parseMode === 'delim') {
        result = this.scanDelim() || '.';
        this.skipUntilToken('}');

    } else {
        console.assert(parseMode === 'math' || parseMode === 'text',
            'Unexpected parse mode: "' + parseMode + '"');

        do {
            this.mathList = this.mathList.concat(this.scanImplicitGroup());
        } while(!this.parseToken('}') &amp;&amp; !this.end());
    }

    this.parseMode = savedParseMode;
    const mathList = this.swapMathList(savedMathList);
    return result ? result : mathList;
}


/**
 * @return {Array.MathAtom|MathAtom}
 * @method Parser#scanToken
 * @private
 */
Parser.prototype.scanToken = function() {
    const token = this.get();
    if (!token) return null;

    let result = null;

    if (token.type === 'space') {
        if (this.parseMode === 'text') {
            result = new MathAtom('text', 'textord', ' ');
        }
    } else if (token.type === 'esc') {
        // RENDER ESCAPE SEQUENCE INDICATOR
        result = new MathAtom(this.parseMode, 'esc', 'ESC');

    } else if (token.type === 'backslash') {
        // RENDER BACKSLASH INDICATOR
        result = new MathAtom(this.parseMode, 'command', '\\');

    } else if (token.type === 'commandliteral' || token.type === 'backslash') {
        // RENDER ESCAPE SEQUENCE
        let body = token.value;
        while (this.hasToken('commandliteral') ||
                this.hasToken('backslash')) {
            body += this.get().value;
        }

        result = new MathAtom(this.parseMode, 'command', body);

    } else if (token.type === 'placeholder') {
        // RENDER PLACEHOLDER
        result = new MathAtom(this.parseMode, 'placeholder', token.value);

    } else if (token.type === 'command') {
        // RENDER COMMAND
        if (token.value === 'placeholder') {
            result = new MathAtom(this.parseMode, 'placeholder', this.scanArg('string'));

        } else if (token.value === 'char') {
            // \char has a special syntax and requires a non-braced integer
            // argument
            let codepoint = Math.floor(this.scanNumber(true));
            if (!isFinite(codepoint) || codepoint &lt; 0 || codepoint > 0x10FFFF) {
                codepoint = 0x2753; // BLACK QUESTION MARK
            }
            result = new MathAtom(this.parseMode,
                this.parseMode === 'math' ? 'mord' : 'textord',
                String.fromCodePoint(codepoint),
                'main');
            result.latex = '{\\char"' +
                ('000000' + codepoint.toString(16)).toUpperCase().substr(-6) + '}';

        } else if (token.value === 'hskip' || token.value === 'kern') {
            // \hskip and \kern have a special syntax and requires a non-braced
            // 'skip' argument
            const width = this.scanSkip();
            if (!isNaN(width)) {
                result = new MathAtom(this.parseMode, 'spacing');
                result.width = width;
            }

        } else {
            result = this.scanMacro(token.value);

            if (!result) {
                const info = Definitions.getInfo('\\' + token.value,
                    this.parseMode, this.macros);
                const args = [];

                // Parse the arguments
                if (info &amp;&amp; info.params) {
                    for (const param of info.params) {
                        // Parse an argument
                        if (param.optional) {
                            // If it's not present, return the default argument value
                            const arg = this.scanOptionalArg(param.type);
                    // args.push(arg ? arg : param.defaultValue); @todo defaultvalue
                            args.push(arg);

                        } else {
                            // If it's not present, scanArg returns null.
                            // Add a placeholder instead.
                            const arg = this.scanArg(param.type);
                            if (arg &amp;&amp; arg.length === 1 &amp;&amp;
                                arg[0].type === 'placeholder' &amp;&amp; param.placeholder) {
                                arg[0].value = param.placeholder;
                            }
                            if (arg) {
                                args.push(arg);
                            } else if (param.placeholder) {
                                args.push([new MathAtom(this.parseMode, 'placeholder', param.placeholder)]);
                            } else {
                                args.push(this.placeholder());
                            }
                        }
                    }
            }

                if (info &amp;&amp; !info.infix) {
                    // Infix commands should be handled in scanImplicitGroup
                    // If we find an infix command here, it's a syntax error
                    // (second infix command in an implicit group) and should be ignored.

                    // Create the MathAtom
                    // If a handler is present, invoke it with the arguments,
                    // and pass the result to be appended by the constructor.
                    if (info.handler) {
                        result =  new MathAtom(
                                this.parseMode, info.type,
                                null,
                                info.fontFamily,
                                info.handler('\\' + token.value, args));
                    } else {
                        result =  new MathAtom(
                                this.parseMode, info.type || 'mop',
                                info.value || token.value,
                                info.fontFamily);
                    }
                    result.latex = '\\' + token.value + ' ';
                    if (result.isFunction &amp;&amp; this.smartFence) {
                        // The atom was a function that may be followed by
                        // an argument, like `\sin(`
                        const smartFence = this.scanSmartFence();
                        if (smartFence) {
                            result = [result, smartFence];
                        }
                    }
                }
            }
        }

    } else if (token.type === 'literal') {
        const info = Definitions.getInfo(token.value, this.parseMode, this.macros);
        if (info) {
            result = new MathAtom(this.parseMode,  info.type,
                info.value || token.value, info.fontFamily);
            if (info.isFunction) {
                result.isFunction = true;
            }
        } else {
            // console.warn('Unknown literal "' + token.value +
            //     '" (U+' + ('000000' + token.value.charCodeAt(0).toString(16)).substr(-6) + ')');
            result = new MathAtom(this.parseMode,
                this.parseMode === 'math' ? 'mord' : 'textord',
                token.value, 'main');
        }
        result.latex = Definitions.matchCodepoint(token.value);

        if (info &amp;&amp; info.isFunction &amp;&amp; this.smartFence) {
            // The atom was a function that may be followed by
            // an argument, like `f(`.
            const smartFence = this.scanSmartFence();
            if (smartFence) {
                result = [result, smartFence];
            }
        }

    } else if (token.type === '#') {
        // Parameter token in an implicit group (not as a parameter)
        if (token.value === '?') {
            // '#?' indicates that a placeholder should be used
            result = this.placeholder();
        } else if (this.args) {
            result = this.args[token.value] || null;
            if (Array.isArray(result) &amp;&amp; result.length === 1) {
                result = result[0];
            } else if (Array.isArray(result)) {
                const group = new MathAtom(this.parseMode, 'group');
                group.body = result;
                result = group;
            } else {
                // If there is no argument value specified, use a placeholder
                result = this.placeholder();
            }
        }
    } else {
        console.warn('Unexpected token type "' + token.type + '"');
    }
    return result;
}

/**
 * Attempt to scan the macro name and return an atom list if successful.
 * Otherwise, it wasn't a macro.
 */
Parser.prototype.scanMacro = function(macro) {
    if (!this.macros || !this.macros[macro]) return null;

    const args = {};
    let def;
    let argCount = 0;
    if (typeof this.macros[macro] === 'string') {
        def = this.macros[macro];
        // Let's see if there are arguments in the definition.
        if (/(^|[^\\])#1/.test(def)) argCount = 1;
        if (/(^|[^\\])#2/.test(def)) argCount = 2;
        if (/(^|[^\\])#3/.test(def)) argCount = 3;
        if (/(^|[^\\])#4/.test(def)) argCount = 4;
        if (/(^|[^\\])#5/.test(def)) argCount = 5;
        if (/(^|[^\\])#6/.test(def)) argCount = 6;
        if (/(^|[^\\])#7/.test(def)) argCount = 7;
        if (/(^|[^\\])#8/.test(def)) argCount = 8;
        if (/(^|[^\\])#9/.test(def)) argCount = 9;
    } else {
        def = this.macros[macro].def;
        argCount = (this.macros[macro].args || 0);
    }
    for (let i = 1; i &lt;= argCount; i++) {
        args[i] = this.scanArg();
    }

    // Carry forward the placeholder argument, if any.
    if (this.args &amp;&amp; typeof this.args['?'] === 'string') {
        args['?'] = this.args['?'];
    }

    // Group the result of the macro expansion, and set the
    // captureSelection attribute so that it is handled as an unbreakable
    // unit
    const atom = new MathAtom(this.parseMode, 'group',
        parseTokens(Lexer.tokenize(def), this.parseMode, args, this.macros));
    atom.captureSelection = true;
    atom.latex = '\\' + macro;

    let argString = '';
    for (let i = 1; i &lt;= argCount; i++) {
        argString += '{';
        if (Array.isArray(args[i])) {
            for (let j = 0; j &lt; args[i].length; j++) {
                argString += args[i][j].latex;
            }
        }
        argString += '}';
    }

    atom.latex += argString ? argString : ' ';

    return atom;
}

/**
 * Make a MathAtom for the current token or token group and
 * add it to the parser's current mathList
 * @method Parser#parseAtom
 * @private
 */
Parser.prototype.parseAtom = function() {
    let result = this.scanEnvironment() ||
         this.scanModeShift() ||
         this.scanModeSet() ||
         this.scanGroup() ||
         this.scanLeftRight();

    if (!result &amp;&amp; (this.parseSupSub() || this.parseLimits())) return true;

    if (!result) result = this.scanToken();

    // If we have an atom to add, push it at the end of the current math list
    // We could have no atom for tokens that were skipped, a ' ' in mathmode
    // for example
    if (Array.isArray(result)) {
        this.mathList = this.mathList.concat(result);
    } else if (result) {
        this.mathList.push(result);
    }

    return result !== null;
}


/**
 * Given an array of tokens returned by the lexer, return a corresponding
 * math list (array of atoms).
 * @param {Array.&lt;Token>} tokens
 * @param {string} [parseMode='math']
 * @param {Array.&lt;string>} [args={}] - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param {*} [macro={}] Dictionary defining macros
 * @param {boolean} [smartFence=false] If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 * @return {Array.&lt;MathAtom>}
 * @private
 */
function parseTokens(tokens, parseMode, args, macros, smartFence) {
    let mathlist = [];
    const parser = new Parser(tokens, args, macros);
    parser.parseMode = parseMode || 'math';  // other possible values: 'text', 'color', etc...
    if (smartFence) parser.smartFence = true;

    while(!parser.end()) {
        mathlist = mathlist.concat(parser.scanImplicitGroup());
    }
    return mathlist;
}

// Export the public interface for this module
export default {
    Parser: Parser,
    parseTokens: parseTokens
}



</code></pre>
        </article>
    </section>




</main>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="scripts/namis.search.jquery.js"></script>
<script>
    function readCookie(a) {
        var b = document.cookie.match('(^|;)\\s*' + a + '\\s*=\\s*([^;]+)');
        return b ? b.pop() : '';
    }
    function writeCookie(a, v) {
		var date = new Date();
		date.setTime(date.getTime()+(30*24*60*60*1000));
    	document.cookie = a + "=" + v + "; expires=" + date.toUTCString() + "; path=/";
    }

    var cookie = readCookie('symbol-access');
    if (cookie === 'no-private') {
        document.documentElement.classList.add('no-private');
    }
    
   document.getElementById('toggle-private').checked = 
    !document.documentElement.classList.contains('no-private');


    prettyPrint();
    (function($){
        $('#nav').search(['className', 'methodName']);
    })(jQuery);
</script>
<script src="scripts/linenumber.js"></script>


    <script src="http://mathlive.io/sprint15/mathlive/mathlive.js"></script><script>if (MathLive) {MathLive.renderMathInDocument();}</script>


</body>
</html>
